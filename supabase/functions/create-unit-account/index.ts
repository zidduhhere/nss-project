import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

type CreateUnitBody = {
  email: string;
  unit_uuid: string;
  full_name?: string;
  password?: string; // optional; autogenerated if omitted
};

const cors = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

function genTempPassword(): string {
  // 16-char alnum + symbols; better than 'password123!'
  const chars =
    "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789!@#$%^&*()_-+=[]{}~";
  let out = "";
  for (let i = 0; i < 16; i++) out += chars[Math.floor(Math.random() * chars.length)];
  return out;
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: cors });
  }

  const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
  const ANON = Deno.env.get("SUPABASE_ANON_KEY")!;
  const SERVICE = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

  const userClient = createClient(SUPABASE_URL, ANON, {
    global: { headers: { Authorization: req.headers.get("Authorization") ?? "" } },
  });
  const admin = createClient(SUPABASE_URL, SERVICE);

  try {
    // 1) Verify caller & admin role (DB is source of truth)
    const { data: meAuth } = await userClient.auth.getUser();
    if (!meAuth?.user) {
      return new Response(JSON.stringify({ error: "Unauthorized" }), { status: 401, headers: cors });
    }
    const { data: roleRow, error: roleErr } = await userClient
      .from("user_roles")
      .select("roles!inner(name)")
      .eq("user_id", meAuth.user.id)
      .single();
    if (roleErr || !roleRow || roleRow.roles.name !== "admin") {
      return new Response(JSON.stringify({ error: "Forbidden" }), { status: 403, headers: cors });
    }

    // 2) Parse body
    const body = (await req.json()) as CreateUnitBody;
    const email = (body.email ?? "").trim().toLowerCase();
    const unit_uuid = (body.unit_uuid ?? "").trim();
    const full_name = body.full_name?.trim() || "NSS Unit";
    const password = body.password?.trim() || genTempPassword();

    if (!email || !unit_uuid) {
      return new Response(JSON.stringify({ error: "email and unit_uuid are required" }), { status: 400, headers: cors });
    }

    // 3) Ensure the unit exists
    const { data: unit, error: unitErr } = await userClient
      .from("nss_units")
      .select("id")
      .eq("id", unit_uuid)
      .single();
    if (unitErr || !unit) {
      return new Response(JSON.stringify({ error: "Unit not found" }), { status: 400, headers: cors });
    }

    // 4) Create auth user (service role)
    const { data: created, error: createErr } = await admin.auth.admin.createUser({
      email,
      password,
      email_confirm: true, // or false if you'd prefer email confirmation
      user_metadata: { full_name },
      app_metadata: { role: "unit", unit_uuid }, // JWT convenience
    });
    if (createErr) {
      return new Response(JSON.stringify({ error: createErr.message }), { status: 400, headers: cors });
    }
    const unitUserId = created.user?.id;
    if (!unitUserId) {
      return new Response(JSON.stringify({ error: "Failed to create auth user" }), { status: 500, headers: cors });
    }

    // 5) Upsert user_roles row
    const { error: upsertErr } = await admin
      .from("user_roles")
      .upsert({ user_id: unitUserId, role_id:  (await getRoleId(admin, "unit")), unit_uuid }, { onConflict: "user_id" });
    if (upsertErr) {
      return new Response(JSON.stringify({ error: upsertErr.message }), { status: 500, headers: cors });
    }

    // 6) Invalidate any previous sessions (unlikely for new user, but safe)
    await admin.auth.admin.invalidateRefreshTokens(unitUserId);

    return new Response(JSON.stringify({ ok: true, user_id: unitUserId, temp_password: password }), {
      status: 200,
      headers: cors,
    });
  } catch (e) {
    return new Response(JSON.stringify({ error: String(e) }), { status: 500, headers: cors });
  }
});

// Helper to fetch role id
async function getRoleId(client: ReturnType<typeof createClient>, name: string): Promise<number> {
  const { data, error } = await client.from("roles").select("id").eq("name", name).single();
  if (error || !data) throw new Error(`Role '${name}' not found`);
  return data.id as number;
}